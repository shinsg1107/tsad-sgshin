from yacs.config import CfgNode as CN


_C = CN()
# random seed number
_C.SEED = 0
# number of gpus per node
_C.NUM_GPUS = 4
_C.VISIBLE_DEVICES = 0
_C.RESULT_DIR = 'results/'



_C.DATA_LOADER = CN()
# the number of data loading workers per gpu
_C.DATA_LOADER.NUM_WORKERS = 4
_C.DATA_LOADER.PIN_MEMORY = True
_C.DATA_LOADER.DROP_LAST = True



_C.DATA = CN()
_C.DATA.BASE_DIR = 'data/'
_C.DATA.NAME = 'SWaT'
_C.DATA.SCALE = "standard"
_C.DATA.WIN_SIZE = 10
_C.DATA.TRAIN_STEP = 1
_C.DATA.TEST_STEP = 1
_C.DATA.N_VAR = 51
_C.DATA.TRAIN_RATIO = 0.8
_C.DATA.DOWNSAMPLE_RATE = 1



_C.TRAIN = CN()
_C.TRAIN.ENABLE = True
_C.TRAIN.BATCH_SIZE = 256
_C.TRAIN.SHUFFLE = True
_C.TRAIN.DROP_LAST = True
_C.TRAIN.SPLIT = 'train'
# directory to save checkpoints
_C.TRAIN.CHECKPOINT_DIR = 'results/'
# path to checkpoint to resume training
_C.TRAIN.RESUME = ''
# epoch period to evaluate on a validation set
_C.TRAIN.EVAL_PERIOD = 5
# iteration frequency to print progress meter
_C.TRAIN.PRINT_FREQ = 100
_C.TRAIN.METRIC_BEST = float("inf")
_C.TRAIN.IS_METRIC_LOWER_BETTER = True



_C.VAL = CN()
_C.VAL.SPLIT = 'val'
_C.VAL.BATCH_SIZE = 256
_C.VAL.SHUFFLE = False
_C.VAL.DROP_LAST = False
_C.VAL.VIS = False



_C.TEST = CN()
_C.TEST.ENABLE = True
_C.TEST.SPLIT = 'test'
_C.TEST.BATCH_SIZE = 256
_C.TEST.SHUFFLE = False
_C.TEST.DROP_LAST = False
_C.TEST.POINT_ADJUST = True
_C.TEST.VIS = True
_C.TEST.THRESHOLD = CN()
_C.TEST.THRESHOLD.TYPE = 'best_f1'  # ratio, best_f1
_C.TEST.THRESHOLD.ANOMALY_RATIO = 0.5
_C.TEST.ANOMALY_SCORES_DIR = ""



_C.SOLVER = CN()
_C.SOLVER.START_EPOCH = 0
_C.SOLVER.MAX_EPOCH = 30
_C.SOLVER.OPTIMIZING_METHOD = 'adam'
_C.SOLVER.BASE_LR = 0.0001
_C.SOLVER.WEIGHT_DECAY = 0.0001
_C.SOLVER.MOMENTUM = 0.9
_C.SOLVER.NESTEROV = True
_C.SOLVER.DAMPENING = 0.0
_C.SOLVER.LR_POLICY = 'cosine'
_C.SOLVER.COSINE_END_LR = 0.0
_C.SOLVER.COSINE_AFTER_WARMUP = True
_C.SOLVER.WARMUP_EPOCHS = 5
_C.SOLVER.WARMUP_START_LR = 0.0001
_C.SOLVER.GRADIENT_CLIP = True
_C.SOLVER.GRADIENT_CLIP_NORM = 0.5



_C.MODEL = CN()
_C.MODEL.NAME = 'CAROTS'


_C.TIMESNET = CN()
_C.TIMESNET.e_layers = 2
_C.TIMESNET.d_model = 512
_C.TIMESNET.d_ff = 64
_C.TIMESNET.enc_in = 51
_C.TIMESNET.c_out = 51
_C.TIMESNET.top_k = 3
_C.TIMESNET.anomaly_ratio = 1
_C.TIMESNET.freq = 'h'
_C.TIMESNET.dropout = 0.1
_C.TIMESNET.num_kernels = 6
_C.TIMESNET.pred_len = 0
_C.TIMESNET.embed = 'timeF'
_C.TIMESNET.METRIC_NAMES = ("Recon",)
_C.TIMESNET.LOSS_NAMES = ("Recon",)



_C.ITRANSFORMER = CN()
_C.ITRANSFORMER.E_LAYERS = 2
_C.ITRANSFORMER.D_MODEL = 512
_C.ITRANSFORMER.D_FF = 512
_C.ITRANSFORMER.N_HEADS = 8
_C.ITRANSFORMER.DROPOUT = 0.1
_C.ITRANSFORMER.ENC_IN = 51
_C.ITRANSFORMER.C_OUT = 51
_C.ITRANSFORMER.FREQ = 'h'
_C.ITRANSFORMER.EMBED = 'timeF'
_C.ITRANSFORMER.IGNORE_STAMP = True
_C.ITRANSFORMER.OUTPUT_ATTENTION = False
_C.ITRANSFORMER.FACTOR = 3
_C.ITRANSFORMER.ACTIVATION = 'gelu'



_C.LSTM = CN()
_C.LSTM.HIDDEN_DIM = 512
_C.LSTM.NUM_LAYERS = 1
_C.LSTM.DROPOUT = 0.0



_C.GRU = CN()
_C.GRU.HIDDEN_DIM = 512
_C.GRU.NUM_LAYERS = 1
_C.GRU.DROPOUT = 0.0



_C.GATV2 = CN()
_C.GATV2.IN_CHANNELS = 32
_C.GATV2.HIDDEN_CHANNELS = 32
_C.GATV2.OUT_CHANNELS = 512
_C.GATV2.HEADS = 1
_C.GATV2.DROPOUT = 0.0



_C.CAROTS = CN()
_C.CAROTS.CAUSALITY_THRESHOLD = 0.5
_C.CAROTS.ENCODER_ARCH = 'lstm'  # lstm, iTransformer, GATv2, TimesNet, gru
_C.CAROTS.METRIC_NAMES = ("Loss",)
_C.CAROTS.LOSS_NAMES = ("Loss",)
_C.CAROTS.TEMPERATURE = 0.1
_C.CAROTS.SIM_THRESHOLD = 0.5
_C.CAROTS.SIM_THRESHOLD_SCHEDULE = True
_C.CAROTS.SIM_THRESHOLD_START = 0.5
_C.CAROTS.SIM_THRESHOLD_END = 0.9

_C.CAROTS.PROJECTOR = CN()
_C.CAROTS.PROJECTOR.INPUT_DIM = 512
_C.CAROTS.PROJECTOR.HIDDEN_DIM = 1024
_C.CAROTS.PROJECTOR.OUTPUT_DIM = 512

_C.CAROTS.POSITIVE_AUGMENTOR = CN()
_C.CAROTS.POSITIVE_AUGMENTOR.ENABLE = True
_C.CAROTS.POSITIVE_AUGMENTOR.NOISE_LEVEL = 0.1

_C.CAROTS.NEGATIVE_AUGMENTOR = CN()
_C.CAROTS.NEGATIVE_AUGMENTOR.TRANSFORM_NAME = "AddBias"
_C.CAROTS.NEGATIVE_AUGMENTOR.CUTOFF_PROBABILITY = 0.1
_C.CAROTS.NEGATIVE_AUGMENTOR.DISTURB_ALL = False

_C.TRANSFORM = CN()
_C.TRANSFORM.AddBias = CN()
_C.TRANSFORM.AddBias.bias_candidates = (0.5, 0.4, 0.3, 0.2, 0.1, -0.1, -0.2, -0.3, -0.4, -0.5)
_C.TRANSFORM.AddBias.percent = 0.5




_C.CAUSAL_DISCOVERER = 'CUTS_PLUS'



_C.CUTS_PLUS = CN()
_C.CUTS_PLUS.DATA_DIM = 1
_C.CUTS_PLUS.N_NODES = 51
_C.CUTS_PLUS.INPUT_STEP = 9
_C.CUTS_PLUS.N_GROUPS = 51
_C.CUTS_PLUS.GROUP_POLICY = 'multiply_2_every_20'
_C.CUTS_PLUS.SUPERVISION_POLICY = 'full'
_C.CUTS_PLUS.FILL_POLICY = 'None'
_C.CUTS_PLUS.SHOW_GRAPH_EVERY = 10
_C.CUTS_PLUS.RESULT_DIR = 'results/cuts_plus/'


_C.CUTS_PLUS.DATA_PRED = CN()
_C.CUTS_PLUS.DATA_PRED.MODEL = 'multi_lstm'
_C.CUTS_PLUS.DATA_PRED.PRED_STEP = 1
_C.CUTS_PLUS.DATA_PRED.MLP_HID = 32
_C.CUTS_PLUS.DATA_PRED.GRU_LAYERS = 1
_C.CUTS_PLUS.DATA_PRED.SHARED_WEIGHTS_DECODER = False
_C.CUTS_PLUS.DATA_PRED.CONCAT_H = True
_C.CUTS_PLUS.DATA_PRED.LR_DATA_START = 0.01
_C.CUTS_PLUS.DATA_PRED.LR_DATA_END = 0.001
_C.CUTS_PLUS.DATA_PRED.WEIGHT_DECAY = 0
_C.CUTS_PLUS.DATA_PRED.PROB = True
_C.CUTS_PLUS.DATA_PRED.GRADIENT_CLIP = False
_C.CUTS_PLUS.DATA_PRED.GRADIENT_CLIP_NORM = 1.0

_C.CUTS_PLUS.GRAPH_DISCOV = CN()
_C.CUTS_PLUS.GRAPH_DISCOV.LAMBDA_S_START = 0.1
_C.CUTS_PLUS.GRAPH_DISCOV.LAMBDA_S_END = 0.01
_C.CUTS_PLUS.GRAPH_DISCOV.LR_GRAPH_START = 0.001
_C.CUTS_PLUS.GRAPH_DISCOV.LR_GRAPH_END = 0.0001
_C.CUTS_PLUS.GRAPH_DISCOV.START_TAU = 1
_C.CUTS_PLUS.GRAPH_DISCOV.END_TAU = 0.1
_C.CUTS_PLUS.GRAPH_DISCOV.DYNAMIC_SAMPLING_MILESTONES = [0]
_C.CUTS_PLUS.GRAPH_DISCOV.DYNAMIC_SAMPLING_PERIODS = [1]
_C.CUTS_PLUS.GRAPH_DISCOV.GRADIENT_CLIP = False
_C.CUTS_PLUS.GRAPH_DISCOV.GRADIENT_CLIP_NORM = 1.0

_C.CUTS_PLUS.CAUSAL_THRES = 'value_0.5'

_C.CUTS_PLUS.TRAIN = CN()
_C.CUTS_PLUS.TRAIN.BATCH_SIZE = 256
_C.CUTS_PLUS.TRAIN.EVAL_PERIOD = 1
_C.CUTS_PLUS.TRAIN.CHECKPOINT_DIR = 'results/cuts_plus/'
_C.CUTS_PLUS.TRAIN.METRIC_BEST = float("inf")

_C.CUTS_PLUS.SOLVER = CN()
_C.CUTS_PLUS.SOLVER.MAX_EPOCH = 50



_C.ORACLEAD = CN()

#ORACLEAD
_C.ORACLEAD.METRIC_NAMES = ("Total", "Pred", "Recon", "Dev")
_C.ORACLEAD.LOSS_NAMES   = ("Total", "Pred", "Recon", "Dev")

_C.ORACLEAD.LAMBDA_RECON = 0.1
_C.ORACLEAD.LAMBDA_DEV   = 3.0

_C.ORACLEAD.SLS = CN()
_C.ORACLEAD.SLS.START_EPOCH = 1   
_C.ORACLEAD.SLS.SAVE_EVERY_EPOCH = True

#LSTM Encoder
_C.ORACLEAD.LSTM_ENCODER = CN()
_C.ORACLEAD.LSTM_ENCODER.INPUT_DIM = 1
_C.ORACLEAD.LSTM_ENCODER.HIDDEN_DIM = 128
_C.ORACLEAD.LSTM_ENCODER.NUM_LAYERS = 2
_C.ORACLEAD.LSTM_ENCODER.DROPOUT = 0.1
_C.ORACLEAD.LSTM_ENCODER.BIDIRECTIONAL = False
_C.ORACLEAD.LSTM_ENCODER.SHARED = False

#MHSA
_C.ORACLEAD.MHSA = CN()
_C.ORACLEAD.MHSA.BACKEND = "torch"   # paper or torch (paper는 논문 수식 그대로 구현)
_C.ORACLEAD.MHSA.DIM = 128           # = causal embedding dim (LSTM out_dim과 일치)
_C.ORACLEAD.MHSA.NUM_HEADS = 4
_C.ORACLEAD.MHSA.BIAS = True

_C.ORACLEAD.MHSA.ATTN_DROPOUT = 0.1
_C.ORACLEAD.MHSA.PROJ_DROPOUT = 0.1  # 없으면 DROPOUT을 fallback
_C.ORACLEAD.MHSA.DROPOUT = 0.1       # optional fallback

_C.ORACLEAD.MHSA.PRE_NORM = True
_C.ORACLEAD.MHSA.RESIDUAL = True
_C.ORACLEAD.MHSA.MASK_SELF = False   # optional

#LSTM Decoder
_C.ORACLEAD.DECODER = CN()
_C.ORACLEAD.DECODER.DIM = 128          
_C.ORACLEAD.DECODER.HIDDEN_DIM = 128
_C.ORACLEAD.DECODER.NUM_LAYERS = 2
_C.ORACLEAD.DECODER.DROPOUT = 0.0
_C.ORACLEAD.DECODER.BIAS = True
_C.ORACLEAD.DECODER.BIDIRECTIONAL = False

_C.ORACLEAD.DECODER.OUT_DIM = 1        # sensor value dimension
_C.ORACLEAD.DECODER.PAST_LEN = 9       # L-1 (예: WIN_SIZE=10이면 9)
_C.ORACLEAD.DECODER.SHARED = False     # 논문처럼 변수별 decoder면 False


_C.SCORER = CN()
_C.SCORER.TYPE = 'l2'  # l2, cos

def get_cfg_defaults():

    return _C.clone()
